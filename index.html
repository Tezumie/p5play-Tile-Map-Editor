<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
        integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script type="module" src="https://unpkg.com/vanilla-colorful?module"></script>

</head>

<body>
    <div id="toolbar">
        <div class="input-container">
            <button id="recenterButton">Center Viewport</button>
            <button id="undoButton" title="Undo"><i class="fas fa-undo"></i></button>
            <button id="redoButton" title="Redo"><i class="fas fa-redo"></i></button>
        </div>

        <div class="settings-container" id="settings">
            <h2>Settings<i class="fa fa-chevron-down"></i></h2>
            <div class="input-container">
                <label for="canvasWidth">Tiles X</label>
                <input type="number" id="canvasWidth" value="40" step="1" />
            </div>
            <div class="input-container">
                <label for="canvasHeight">Tiles Y</label>
                <input type="number" id="canvasHeight" value="24" />
            </div>
            <div class="input-container">
                <button id="setCanvasSize">Apply Settings</button>
            </div>
        </div>
        <div class="settings-container collapsed" id="imageSettings">
            <h2>Image<i class="fa fa-chevron-right"></i></h2>
            <div class="input-container">
                <button id="backgroundImageButton">Reference Image</button>
                <input type="file" id="overlayUpload" accept="image/*" hidden />
                <button id="toggleOverlayImage"></button>
            </div>
            <div class="input-container">
                <button title="Generate a tilemap from an image"id="canvasImageButton">Set Canvas Image</button>
                <input type="file" id="imageUpload" accept="image/*" hidden />
                <button title="Download tilemap as an image" id="download" class="download" title="Download Canvas Image"><i class="fa-solid fa-download"></i></button>
            </div>
        </div>
        <div class="settings-container" id="palette">
            <h2>Palette<i class="fa fa-chevron-down"></i></h2>
            <hex-color-picker id="colorPicker" color="#000000"></hex-color-picker>
            <div id="colorPalette"></div>
        </div>

        <div class="settings-container" id="palette">
            <h2>Export<i class="fa fa-chevron-down"></i></h2>
            <div class="input-container">
                <button title="Copy tilemap string to clipboard"id="copyButton"><i class="fa-regular fa-copy"></i> Copy</button>
                <button title="Download tilemap as an image" id="download2" class="download" title="Download Canvas Image"><i class="fa-solid fa-download"></i></button>
                <button title="Expand/Collapse your tilemap text area" id="toggleExpandButton"><i class="fa-solid fa-maximize"></i></button>
            </div>
            <textarea id="pixelData" spellcheck="false"></textarea>
        </div>
    </div>

    <div id="canvas-container">
        <div id="referenceOverlay"></div>
        <canvas id="canvas"></canvas>
        <div id="overlay"></div>
        <div id="cursor"></div>
        <div id="linePreview"></div>
    </div>

    <div class="tools">
        <input type="number" id="drawSize" class="pixelSize" value="1" min="1" title="Draw Tool Pixel Size" />
        <button id="penTool" class="tool-button active" data-tool="pen" title="Pen">
            <i class="fas fa-pen"></i>
        </button>
        <button id="lineTool" class="tool-button" data-tool="line" title="Line">
            <i class="fas fa-slash"></i>
        </button>
        <button id="fillTool" class="tool-button" data-tool="fill" title="Fill">
            <i class="fas fa-fill-drip"></i>
        </button>
        <button id="clearCanvasButton" title="Clear Canvas"><i class="fas fa-trash-alt"></i></button>

    </div>

    <script>
        document.querySelectorAll('input[type="number"]').forEach((input) => {
                input.addEventListener('wheel', (event) => {
                    event.preventDefault(); // Prevent page scrolling
                    const step = parseInt(input.step) || 1; // Use the step value (default to 1)
                    const delta = Math.sign(event.deltaY); // Get scroll direction

                    // Calculate new value, ensuring it doesn't go below 1
                    const newValue = Math.max(1, parseInt(input.value) - delta * step);
                    input.value = newValue;

                    input.dispatchEvent(new Event('input')); // Trigger input event
                });
            });

            const toggleExpandButton = document.getElementById("toggleExpandButton");
            const pixelData = document.getElementById("pixelData");

            // Add event listener for toggling class and changing button icon
            toggleExpandButton.addEventListener("click", () => {
                pixelData.classList.toggle("expanded");
                toggleExpandButton.classList.toggle("active");

                // Update button icon and active state based on the current state
                if (pixelData.classList.contains("expanded")) {
                    toggleExpandButton.innerHTML = '<i class="fa-solid fa-minimize"></i>';
                } else {
                    toggleExpandButton.innerHTML = '<i class="fa-solid fa-maximize"></i>';
                }
            });


            document.querySelectorAll('.settings-container h2').forEach(header => {
                header.onclick = () => {
                    const container = header.parentElement;
                    const chevron = header.querySelector('.fa-chevron-down, .fa-chevron-right');

                    const isCollapsed = container.classList.toggle('collapsed');

                    if (chevron) {
                    chevron.classList.toggle('fa-chevron-right', isCollapsed);
                    chevron.classList.toggle('fa-chevron-down', !isCollapsed);
                    }
                };
                });
            let backgroundImg
            let isBackgroundVisible = false

            document.getElementById("canvasImageButton").addEventListener("click", () => {
                document.getElementById("imageUpload").click();
            });
            document.getElementById("backgroundImageButton").addEventListener("click", () => {
                document.getElementById("overlayUpload").click();
            });

            document.getElementById("overlayUpload").addEventListener("change", function (event) {
                const file = event.target.files[0]
                if (file) {
                    const reader = new FileReader()
                    reader.onload = function (e) {
                        backgroundImg = e.target.result
                        const referenceOverlay = document.getElementById("referenceOverlay")
                        referenceOverlay.style.backgroundImage = `url(${backgroundImg})`
                        isBackgroundVisible = true
                        document.getElementById("toggleOverlayImage").classList.add("active")
                    }
                    reader.readAsDataURL(file)
                }
            })

            document.getElementById("toggleOverlayImage").addEventListener("click", function () {
                const referenceOverlay = document.getElementById("referenceOverlay")
                if (!backgroundImg) {
                    alert("Set a background image first")
                    return
                }
                if (isBackgroundVisible) {
                    this.classList.remove("active")
                    referenceOverlay.style.backgroundImage = `none`
                    isBackgroundVisible = false
                } else {
                    this.classList.add("active")
                    referenceOverlay.style.backgroundImage = `url(${backgroundImg})`
                    isBackgroundVisible = true
                }
            })

            class PixelArtEditor {
                constructor() {
                    this.canvas = document.getElementById("canvas")
                    this.ctx = this.canvas.getContext("2d")
                    this.overlay = document.getElementById("overlay")
                    this.referenceOverlay = document.getElementById("referenceOverlay")
                    this.canvasWidthInput = document.getElementById("canvasWidth")
                    this.canvasHeightInput = document.getElementById("canvasHeight")
                    this.drawSizeInput = document.getElementById("drawSize")
                    this.colorPicker = document.getElementById("colorPicker")
                    this.setCanvasSizeButton = document.getElementById("setCanvasSize")
                    this.canvasContainer = document.getElementById("canvas-container")
                    this.colorPalette = document.getElementById("colorPalette")
                    this.pixelDataTextArea = document.getElementById("pixelData")
                    this.copyButton = document.getElementById("copyButton")
                    this.undoButton = document.getElementById("undoButton")
                    this.redoButton = document.getElementById("redoButton")
                    this.cursor = document.getElementById("cursor")
                    this.linePreview = document.getElementById("linePreview")
                    this.penToolButton = document.getElementById("penTool")
                    this.lineToolButton = document.getElementById("lineTool")
                    this.fillToolButton = document.getElementById("fillTool")
                                    this.imageUpload = document.getElementById("imageUpload");
                this.imageUpload.addEventListener("change", (e) => this.handleImageUpload(e));                    this.activeTool = "pen"
                    this.lineStart = null
                    this.scale = 1
                    this.panX = 0
                    this.panY = 0
                    this.isPanning = false
                    this.startX = 0
                    this.startY = 0
                    this.isDrawing = false
                    this.isErasing = false
                    this.lastClickedPixel = null
                    this.hoveredPixel = null
                    this.pixelData = []
                    this.drawSize = parseInt(this.drawSizeInput.value, 10)
                    this.defaultColors = {
                        ".": "#ffffff00",
                        a: "#00FFFF",
                        A: "#99FFFF",
                        b: "#000000",
                        B: "#666666",
                        c: "#DC143C",
                        C: "#F4A6B4",
                        d: "#9400D3",
                        D: "#C68ED9",
                        e: "#FFDAB9",
                        E: "#FFF2DF",
                        f: "#808000",
                        F: "#C0C080",
                        g: "#008000",
                        G: "#66CC66",
                        h: "#FF69B4",
                        H: "#FFBFD8",
                        i: "#4B0082",
                        I: "#9370DB",
                        j: "#000080",
                        J: "#666699",
                        k: "#F0E68C",
                        K: "#FAF8CC",
                        l: "#00FF00",
                        L: "#99FF99",
                        m: "#FF00FF",
                        M: "#FF99FF",
                        n: "#A52A2A",
                        N: "#D3A2A2",
                        o: "#FFA500",
                        O: "#FFD599",
                        p: "#FFC0CB",
                        P: "#FFD9E2",
                        q: "#40E0D0",
                        Q: "#A0F0E0",
                        r: "#FF0000",
                        R: "#FF9999",
                        s: "#87CEEB",
                        S: "#C3E7F7",
                        t: "#D2B48C",
                        T: "#EBDCC8",
                        u: "#0000FF",
                        U: "#9999FF",
                        v: "#EE82EE",
                        V: "#F7C6F7",
                        w: "#fffcfc",
                        W: "#f3f3f3",
                        x: "#FFD700",
                        X: "#FFEB99",
                        y: "#FFFF00",
                        Y: "#FFFF99",
                        z: "#808080",
                        Z: "#C0C0C0",
                        "-": "#F0E68C",
                        "=": "#E6E6FA",
                    }
                    this.activeColor = "#000000" // Default color
                    this.activeColorKey = "b" // Default key
                    this.undoStack = []
                    this.redoStack = []
                    this.init()
                }

                init() {
                    this.createColorPalette()
                    this.setCanvasSizeButton.addEventListener("click", () => this.setCanvasSize())
                    this.drawSizeInput.addEventListener("input", (e) => this.updateDrawSize(e))
                    this.canvas.addEventListener("mousedown", (e) => this.handleMouseDown(e))
                    this.canvas.addEventListener("mousemove", (e) => this.handleMouseMove(e))
                    this.canvas.addEventListener("mouseout", (e) => {
                        this.hideCursor()
                        this.hideLinePreview()
                    })
                    this.canvas.addEventListener("mouseup", () => this.handleMouseUp())
                    this.canvas.addEventListener("contextmenu", (e) => e.preventDefault())
                    this.canvasContainer.addEventListener("contextmenu", (e) => e.preventDefault())
                    this.canvasContainer.addEventListener("mousedown", (e) => this.handlePanningStart(e))
                    this.canvasContainer.addEventListener("mousemove", (e) => this.handlePanningMove(e))
                    this.canvasContainer.addEventListener("mouseup", () => this.handlePanningEnd())
                    this.canvasContainer.addEventListener("wheel", (e) => this.handleZoom(e))
                    window.addEventListener("keydown", (e) => this.handleKeyDown(e))

                    window.addEventListener("resize", () => this.handleResize())
                    this.colorPicker.addEventListener("color-changed", (event) => this.handleColorChange(event))
                    this.copyButton.addEventListener("click", () => this.copyPixelData())
                    this.pixelDataTextArea.addEventListener(
                        "input",
                        this.debounce(() => this.handlePixelDataInput(), 300)
                    )
                    this.undoButton.addEventListener("click", () => this.undo())
                    this.redoButton.addEventListener("click", () => this.redo())
                    this.penToolButton.addEventListener("click", () => this.setActiveTool("pen"))
                    this.lineToolButton.addEventListener("click", () => this.setActiveTool("line"))
                    this.fillToolButton.addEventListener("click", () => this.setActiveTool("fill"))
                    const downloadButtons = document.querySelectorAll('.download');
                    downloadButtons.forEach(button => {
                        button.addEventListener('click', () => this.downloadImage());
                    });
                    document.getElementById("recenterButton").addEventListener("click", () => this.recenterViewport());
                        document.getElementById("clearCanvasButton").addEventListener("click", () => this.clearCanvas());
                    this.setCanvasSize()
                }

                downloadImage() {
                    const link = document.createElement("a")
                    link.href = this.canvas.toDataURL("image/png")
                    link.download = "pixel_art.png"
                    link.click()
                }

                setActiveTool(tool) {
                    this.activeTool = tool
                    this.penToolButton.classList.toggle("active", tool === "pen")
                    this.lineToolButton.classList.toggle("active", tool === "line")
                    this.fillToolButton.classList.toggle("active", tool === "fill")
                    this.lineStart = null
                    this.hideLinePreview()
                }

                debounce(func, wait) {
                    let timeout
                    return (...args) => {
                        clearTimeout(timeout)
                        timeout = setTimeout(() => func.apply(this, args), wait)
                    }
                }

                createColorPalette() {
                    this.colorPalette.innerHTML = "";
                    for (const [key, value] of Object.entries(this.defaultColors)) {
                        const colorBox = document.createElement("div");
                        colorBox.className = "color-box";
                        colorBox.style.backgroundColor = value;
                        colorBox.dataset.color = value;
                        colorBox.dataset.key = key;

                        const textColor = this.getContrastColor(value); // Get contrast color

                        colorBox.innerHTML = `<span style="color: ${textColor}">${key}</span>`;
                        
                        if (value === this.activeColor) {
                            colorBox.dataset.active = "true";
                        }
                        
                        colorBox.addEventListener("click", () => {
                            this.setActiveColor(value, key);
                        });

                        this.colorPalette.appendChild(colorBox);
                    }
                }

                getContrastColor(hex) {
                    const [r, g, b] = this.hexToRgb(hex);
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                    return brightness > 128 ? "#000000" : "#FFFFFF";
                }

                setActiveColor(color, key) {
                    this.activeColor = color
                    this.activeColorKey = key
                    this.colorPicker.color = color
                    this.createColorPalette()
                }

                updatePaletteColor(color, key) {
                    this.defaultColors[key] = color
                    this.createColorPalette()
                    this.redrawCanvas()
                }

                handleColorChange(event) {
                    if (this.activeColorKey != ".") {
                        const newColor = event.detail.value
                        this.activeColor = newColor
                        this.defaultColors[this.activeColorKey] = newColor
                        this.updatePaletteColor(newColor, this.activeColorKey)
                    }
                }

                clearCanvas() {
                    const confirmed = confirm("Are you sure you want to clear the canvas? This action cannot be undone.");
                    if (confirmed) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.initializePixelData(this.canvas.width, this.canvas.height);
                        this.updatePixelDataTextArea();
                        this.saveState(); 
                    }
                }

                setCanvasSize() {
                    const width = parseInt(this.canvasWidthInput.value, 10);
                    const height = parseInt(this.canvasHeightInput.value, 10);

                    // Store the current content in an offscreen canvas
                    const offscreenCanvas = document.createElement("canvas");
                    const offscreenCtx = offscreenCanvas.getContext("2d");

                    offscreenCanvas.width = this.canvas.width;
                    offscreenCanvas.height = this.canvas.height;
                    offscreenCtx.drawImage(this.canvas, 0, 0);

                    // Resize the main canvas
                    this.canvas.width = width;
                    this.canvas.height = height;

                    // Set transparent background and redraw the stored content
                    this.ctx.fillStyle = "#ffffff00";
                    this.ctx.fillRect(0, 0, width, height);
                    this.ctx.drawImage(
                        offscreenCanvas,
                        0, 0, Math.min(width, offscreenCanvas.width), Math.min(height, offscreenCanvas.height),
                        0, 0, Math.min(width, offscreenCanvas.width), Math.min(height, offscreenCanvas.height)
                    );

                    this.fitCanvasToContainer();
                    this.updateOverlaySize();
                    this.createGrid();

                    // Adjust pixel data to match the new canvas size
                    this.trimPixelData(width, height);
                    this.updatePixelDataTextArea();
                    this.saveState();
                }

                // Trims pixel data to fit the new canvas size without losing existing data
                trimPixelData(newWidth, newHeight) {
                    const trimmedData = Array.from({ length: newHeight }, (_, y) =>
                        Array.from({ length: newWidth }, (_, x) =>
                            (this.pixelData[y] && this.pixelData[y][x]) ? this.pixelData[y][x] : "."
                        )
                    );
                    this.pixelData = trimmedData;
                }



  fitCanvasToContainer() {
                const containerWidth = this.canvasContainer.clientWidth;
                const containerHeight = this.canvasContainer.clientHeight;
                this.scale = Math.min(
                    containerWidth / this.canvas.width,
                    containerHeight / this.canvas.height
                ) / 2;
                this.panX = (containerWidth - this.canvas.width * this.scale) / 2;
                this.panY = (containerHeight - this.canvas.height * this.scale) / 2;
                this.updateCanvasTransform();
            }

            updateCanvasTransform() {
                const transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
                this.canvas.style.transformOrigin = '0 0';
                this.canvas.style.transform = transform;
                this.overlay.style.transformOrigin = '0 0';
                this.overlay.style.transform = transform;
                this.referenceOverlay.style.transformOrigin = '0 0';
                this.referenceOverlay.style.transform = transform;
            }


                updateOverlaySize() {
                    this.overlay.style.width = `${this.canvas.width}px`
                    this.overlay.style.height = `${this.canvas.height}px`
                    this.referenceOverlay.style.width = `${this.canvas.width}px`
                    this.referenceOverlay.style.height = `${this.canvas.height}px`
                }

                createGrid() {
                    const offscreenCanvas = document.createElement("canvas")
                    const offscreenCtx = offscreenCanvas.getContext("2d")
                    const gridSize = 10

                    offscreenCanvas.width = this.canvas.width * gridSize
                    offscreenCanvas.height = this.canvas.height * gridSize

                    offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height)
                    offscreenCtx.strokeStyle = "black"
                    offscreenCtx.lineWidth = 0.2

                    for (let x = 0; x <= offscreenCanvas.width; x += gridSize * 8) {
                        offscreenCtx.beginPath()
                        offscreenCtx.moveTo(x, 0)
                        offscreenCtx.lineTo(x, offscreenCanvas.height)
                        offscreenCtx.stroke()
                    }
                    for (let y = 0; y <= offscreenCanvas.height; y += gridSize * 8) {
                        offscreenCtx.beginPath()
                        offscreenCtx.moveTo(0, y)
                        offscreenCtx.lineTo(offscreenCanvas.width, y)
                        offscreenCtx.stroke()
                    }

                    const gridDataURL = offscreenCanvas.toDataURL()
                    this.overlay.style.backgroundImage = `url(${gridDataURL})`
                    this.overlay.style.backgroundSize = `${this.canvas.width}px ${this.canvas.height}px`
                }

                initializePixelData(width, height) {
                    this.pixelData = Array.from({ length: height }, () => Array.from({ length: width }, () => "."))
                }

                getMousePos(event) {
                    const rect = this.canvas.getBoundingClientRect()
                    const x = (event.clientX - rect.left) * (this.canvas.width / rect.width)
                    const y = (event.clientY - rect.top) * (this.canvas.height / rect.height)
                    return { x: Math.floor(x), y: Math.floor(y) }
                }

                drawPixel(x, y, color, update = true, drawingsize = this.drawSize) {
                    this.ctx.fillStyle = color
                    this.hideCursor()
                    this.hideLinePreview()

                    x = Math.round(x)
                    y = Math.round(y)

                    const halfSize = Math.floor(drawingsize / 2)
                    const startX = x - halfSize
                    const startY = y - halfSize
                    const endX = x + halfSize + (drawingsize % 2 === 0 ? 0 : 1)
                    const endY = y + halfSize + (drawingsize % 2 === 0 ? 0 : 1)

                    for (let dx = startX; dx < endX; dx++) {
                        for (let dy = startY; dy < endY; dy++) {
                            if (dx >= 0 && dx < this.canvas.width && dy >= 0 && dy < this.canvas.height) {
                                if (color === "#ffffff00") {
                                    this.ctx.clearRect(dx, dy, 1, 1) // Clear the pixel
                                } else {
                                    this.ctx.fillRect(dx, dy, 1, 1) // Draw the pixel
                                }
                                if (update) {
                                    this.updatePixelData(dx, dy, color)
                                }
                            }
                        }
                    }
                }

                canvasToScreen(x, y) {
                    return {
                        x: x * this.scale + this.panX,
                        y: y * this.scale + this.panY
                    }
                }

                drawCursor(erasing = false, x, y, color, update = true, drawingsize = this.drawSize) {
                    x = Math.round(x)
                    y = Math.round(y)
                    if (this.isPanning) {
                        this.hideCursor()
                        return
                    }
                    this.cursor.style.border = "1px solid black"
                    this.cursor.style.display = "block"
                    if (erasing) {
                        this.cursor.style.backgroundColor = "transparent"
                    } else {
                        this.cursor.style.backgroundColor = color
                    }
                    const halfSize = Math.floor(drawingsize / 2)
                    const startX = x - halfSize
                    const startY = y - halfSize

                    const screenPos = this.canvasToScreen(startX, startY)

                    this.cursor.style.width = `${drawingsize * this.scale}px`
                    this.cursor.style.height = `${drawingsize * this.scale}px`
                    this.cursor.style.left = `${screenPos.x}px`
                    this.cursor.style.top = `${screenPos.y}px`
                }

                hideCursor() {
                    this.cursor.style.display = "none"
                }

                hideLinePreview() {
                    this.linePreview.style.display = "none"
                }

                showLinePreview(x0, y0, x1, y1) {
                    x0 = Math.round(x0)
                    y0 = Math.round(y0)
                    x1 = Math.round(x1)
                    y1 = Math.round(y1)

                    const halfSize = Math.floor(this.drawSize / 2)

                    const startX = x0 - halfSize
                    const startY = y0 - halfSize
                    const endX = x1 - halfSize
                    const endY = y1 - halfSize

                    const screenStart = this.canvasToScreen(startX, startY)
                    const screenEnd = this.canvasToScreen(endX, endY)

                    const deltaX = screenEnd.x - screenStart.x
                    const deltaY = screenEnd.y - screenStart.y
                    const lineWidth = Math.hypot(deltaX, deltaY)
                    const rotation = Math.atan2(deltaY, deltaX)

                    this.linePreview.style.left = `${screenStart.x}px`
                    this.linePreview.style.top = `${screenStart.y}px`
                    this.linePreview.style.width = `${lineWidth}px`
                    this.linePreview.style.height = "2px"
                    this.linePreview.style.transform = `rotate(${rotation}rad)`
                    this.linePreview.style.transformOrigin = "0 0"
                    this.linePreview.style.display = "block"
                }

                updatePixelData(x, y, color) {
                    if (x >= 0 && x < this.canvas.width && y >= 0 && y < this.canvas.height) {
                        const colorKey = Object.keys(this.defaultColors).find(
                            (key) => this.defaultColors[key] === color
                        )
                        this.pixelData[y][x] = colorKey ? colorKey : "."
                        this.updatePixelDataTextArea()
                    }
                }

                updatePixelDataTextArea() {
                    const cursorPosition = this.pixelDataTextArea.selectionStart
                    this.pixelDataTextArea.value = this.pixelData.map((row) => `"${row.join("")}",`).join("\n")
                    this.pixelDataTextArea.selectionStart = cursorPosition
                    this.pixelDataTextArea.selectionEnd = cursorPosition
                }

                handleKeyDown(e) {
                    if (e.ctrlKey && e.key === "z") {
                        this.undo()
                    } else if (e.ctrlKey && e.key === "y") {
                        this.redo()
                    }
                }

                handleMouseDown(e) {
                    const pos = this.getMousePos(e)

                    if (this.activeTool === "pen") {
                        this.lastClickedPixel = pos
                        if (e.button === 0) {
                            this.saveState()
                            this.isDrawing = true
                            this.drawPixel(pos.x, pos.y, this.activeColor)
                        } else if (e.button === 2) {
                            this.saveState()
                            this.isErasing = true
                            this.drawPixel(pos.x, pos.y, "#ffffff00") // Use transparent color
                        }
                    } else if (this.activeTool === "line") {
                        if (e.button === 0) {
                            if (!this.lineStart) {
                                this.lineStart = pos
                                this.drawPixel(pos.x, pos.y, this.activeColor, false)
                            } else {
                                this.saveState()
                                this.drawLine(this.lineStart.x, this.lineStart.y, pos.x, pos.y, this.activeColor)
                                this.lineStart = null
                                this.hideLinePreview()
                            }
                        }
                    } else if (this.activeTool === "fill") {
                        if (e.button === 0) {
                            this.saveState()
                            this.fillArea(pos.x, pos.y, this.activeColor)
                        } else if (e.button === 2) {
                            this.saveState()
                            this.isErasing = true
                            this.fillArea(pos.x, pos.y, "#ffffff00") // Use transparent color
                        }
                    }
                }

                drawLine(x0, y0, x1, y1, color) {
                    const dx = Math.abs(x1 - x0)
                    const dy = Math.abs(y1 - y0)
                    const sx = x0 < x1 ? 1 : -1
                    const sy = y0 < y1 ? 1 : -1
                    let err = dx - dy

                    while (true) {
                        this.drawPixel(x0, y0, color)
                        if (x0 === x1 && y0 === y1) break
                        const e2 = 2 * err
                        if (e2 > -dy) {
                            err -= dy
                            x0 += sx
                        }
                        if (e2 < dx) {
                            err += dx
                            y0 += sy
                        }
                    }
                }

                handleMouseMove(e) {
                    const pos = this.getMousePos(e)
                    this.hoveredPixel = pos
                    if (this.isDrawing || this.isErasing) {
                        if (this.isDrawing) {
                            this.drawPixel(pos.x, pos.y, this.activeColor)
                        } else if (this.isErasing) {
                            this.drawPixel(pos.x, pos.y, "#ffffff00") // Use transparent color
                            this.drawCursor(true, pos.x, pos.y, this.activeColor, false)
                        }
                    } else {
                        this.drawCursor(false, pos.x, pos.y, this.activeColor, false)
                        if (this.activeTool === "line" && this.lineStart) {
                            this.showLinePreview(this.lineStart.x, this.lineStart.y, pos.x, pos.y)
                        }
                    }
                }

                handleMouseUp() {
                    this.isDrawing = false
                    this.isErasing = false
                }

                handlePanningStart(e) {
                    if (e.button === 1) {
                        this.isPanning = true
                        this.startX = e.clientX
                        this.startY = e.clientY
                        this.initialPanX = this.panX
                        this.initialPanY = this.panY
                        this.canvasContainer.style.cursor = "grabbing"
                        e.preventDefault()
                    }
                }

                handlePanningMove(e) {
                    if (this.isPanning) {
                        this.panX = this.initialPanX + (e.clientX - this.startX)
                        this.panY = this.initialPanY + (e.clientY - this.startY)
                        this.updateCanvasTransform()
                    }
                }

                handlePanningEnd() {
                    if (this.isPanning) {
                        this.isPanning = false
                        this.canvasContainer.style.cursor = "default"
                    }
                }

                handleZoom(e) {
                    e.preventDefault()
                    const zoomFactor = 0.1

                    const rect = this.canvasContainer.getBoundingClientRect()
                    const mouseX = e.clientX - rect.left
                    const mouseY = e.clientY - rect.top

                    const oldScale = this.scale
                    if (e.deltaY < 0) {
                        this.scale *= 1 + zoomFactor
                    } else {
                        this.scale /= 1 + zoomFactor
                    }

                    const scaleChange = this.scale / oldScale

                    // Adjust pan to keep mouse position stable
                    this.panX -= (mouseX - this.panX) * (scaleChange - 1)
                    this.panY -= (mouseY - this.panY) * (scaleChange - 1)

                    this.updateCanvasTransform()
                }

                recenterViewport() {
                    this.fitCanvasToContainer()
                }

                handleResize() {
                    this.fitCanvasToContainer()
                    this.updateOverlaySize()
                }

                copyPixelData() {
                    this.pixelDataTextArea.select();
                    document.execCommand("copy");
                    
                    this.copyButton.innerHTML = `<i class="fa-solid fa-check"></i> Copied!`;
                    setTimeout(() => {
                        this.copyButton.innerHTML = '<i class="fa-regular fa-copy"></i> Copy';
                    }, 1000);
                }

                handlePixelDataInput() {
                    const data = this.pixelDataTextArea.value
                        .split("\n")
                        .map((line) => line.trim().replace(/^"(.*)",$/, "$1"))

                    if (
                        data.length !== this.pixelData.length ||
                        data.some((row) => row.length !== this.pixelData[0].length)
                    ) {
                        return
                    }

                    this.saveState()

                    for (let y = 0; y < data.length; y++) {
                        for (let x = 0; x < data[y].length; x++) {
                            const key = data[y][x]
                            const color = this.defaultColors[key] || "#ffffff00"
                            this.drawPixel(x, y, color, true, 1)
                        }
                    }
                }

                saveState() {
                    this.undoStack.push(this.pixelData.map((row) => row.slice()))
                    this.redoStack = []
                }

                undo() {
                    if (this.undoStack.length > 0) {
                        this.redoStack.push(this.pixelData.map((row) => row.slice()))
                        this.pixelData = this.undoStack.pop()
                        this.redrawCanvas()
                        this.updatePixelDataTextArea()
                    }
                }

                redo() {
                    if (this.redoStack.length > 0) {
                        this.undoStack.push(this.pixelData.map((row) => row.slice()))
                        this.pixelData = this.redoStack.pop()
                        this.redrawCanvas()
                        this.updatePixelDataTextArea()
                    }
                }

                redrawCanvas() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
                    this.ctx.fillStyle = "#ffffff00"
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)
                    for (let y = 0; y < this.pixelData.length; y++) {
                        for (let x = 0; x < this.pixelData[y].length; x++) {
                            const key = this.pixelData[y][x]
                            const color = this.defaultColors[key] || "#ffffff00"
                            this.ctx.fillStyle = color
                            this.ctx.fillRect(x, y, 1, 1)
                        }
                    }
                }

                updateDrawSize(event) {
                    this.drawSize = parseInt(event.target.value, 10)
                }

                fillArea(x, y, color) {
                    const targetColor = this.ctx.getImageData(x, y, 1, 1).data
                    const fillRgb = this.hexToRgb(color)

                    // Check if the target color is the same as the fill color
                    if (this.colorsMatch(targetColor, fillRgb)) return

                    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
                    const data = imageData.data
                    const width = this.canvas.width
                    const stack = [[x, y]]

                    const getColorAt = (x, y) => {
                        const index = (y * width + x) * 4
                        return [data[index], data[index + 1], data[index + 2], data[index + 3]]
                    }

                    const setColorAt = (x, y, color) => {
                        const index = (y * width + x) * 4
                        data[index] = color[0]
                        data[index + 1] = color[1]
                        data[index + 2] = color[2]
                        data[index + 3] = color[3]
                    }

                    const visited = new Set()
                    const key = (x, y) => `${x},${y}`

                    while (stack.length > 0) {
                        const [currX, currY] = stack.pop()
                        if (visited.has(key(currX, currY))) continue
                        visited.add(key(currX, currY))

                        const currentColor = getColorAt(currX, currY)
                        if (!this.colorsMatch(currentColor, targetColor)) continue

                        if (color === "#ffffff00") {
                            setColorAt(currX, currY, [0, 0, 0, 0])
                        } else {
                            setColorAt(currX, currY, fillRgb)
                        }

                        const colorKey = Object.keys(this.defaultColors).find(
                            (key) => this.defaultColors[key] === color
                        )
                        this.pixelData[currY][currX] = colorKey ? colorKey : "."

                        if (currX + 1 < width) stack.push([currX + 1, currY])
                        if (currX - 1 >= 0) stack.push([currX - 1, currY])
                        if (currY + 1 < this.canvas.height) stack.push([currX, currY + 1])
                        if (currY - 1 >= 0) stack.push([currX, currY - 1])
                    }

                    this.ctx.putImageData(imageData, 0, 0)
                    this.updatePixelDataTextArea()
                }

                colorsMatch(a, b) {
                    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
                }

                hexToRgb(hex) {
                    const bigint = parseInt(hex.slice(1), 16)
                    const r = (bigint >> 16) & 255
                    const g = (bigint >> 8) & 255
                    const b = bigint & 255
                    return [r, g, b, 255]
                }

          handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => this.processImage(img);
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
 
 processImage(img) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = this.canvas.width;
    canvas.height = this.canvas.height;

    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const processedData = new Uint8ClampedArray(data.length); // Store processed pixels
    this.pixelData = Array.from({ length: canvas.height }, () => Array(canvas.width).fill(".")); // Reset pixelData

    const width = canvas.width;
    const height = canvas.height;

    // Process pixels and update pixelData
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];

            const closestColor = this.getClosestColor(r, g, b, a);
            const [newR, newG, newB, newA] = this.hexToRgb(closestColor);

            // Update processedData for drawing
            processedData[index] = newR;
            processedData[index + 1] = newG;
            processedData[index + 2] = newB;
            processedData[index + 3] = newA;

            // Update pixelData for the textarea
            const colorKey = Object.entries(this.defaultColors).find(
                ([, value]) => value === closestColor
            )?.[0] || ".";
            
            this.pixelData[y][x] = colorKey;
        }
    }

    // Draw the entire image once
    const newImageData = new ImageData(processedData, width, height);
    this.ctx.putImageData(newImageData, 0, 0);

    // Update the textarea with the new pixelData
    this.updatePixelDataTextArea();
    this.saveState(); // Save the current state
}



                getClosestColor(r, g, b, a) {
                    if (a < 128) return "#ffffff00"

                    let closestColor = null
                    let minDistance = Infinity

                    for (const [key, color] of Object.entries(this.defaultColors)) {
                        if (key === ".") continue // Ignore the color associated with "."

                        const [r2, g2, b2] = this.hexToRgb(color)
                        const distance = Math.sqrt((r - r2) ** 2 + (g - g2) ** 2 + (b - b2) ** 2)

                        if (distance < minDistance) {
                            minDistance = distance
                            closestColor = color
                        }
                    }

                    return closestColor
                }
            }

            const editor = new PixelArtEditor()
    </script>
</body>

</html>